package entities

import (
	"fmt"
	"slices"

	"github.com/google/uuid"
)

// StudentGroup represents a university student group in a scheduling context.
//
// The model enforces curriculum load constraints, disallows simultaneous classes and day overloads.
type StudentGroup struct {
	BusyGrid                     // Availability grid.
	StudentLoadService           // Handles student group load validation logic.
	LessonTypeBinder             // Handles lesson type binding logic.
	ID                 uuid.UUID // Unique identifier of the StudentGroup.
	Name               string    // Human-readable identifier of the StudentGroup.
	MaxLessonsPerDay   int       // Day load limit.
	connectedGroups    []*StudentGroup
}

// NewStudentGroup creates a new StudentGroup instance.
//
// It requires student group id, name, max lessons per day (dl),
// busy grid (bg), student load service (sls), and lesson type binder (ltb).
func NewStudentGroup(
	id uuid.UUID, name string, dl int,
	bg *BusyGrid, sls StudentLoadService, ltb LessonTypeBinder,
) *StudentGroup {
	return &StudentGroup{ID: id,
		Name:               name,
		MaxLessonsPerDay:   dl,
		BusyGrid:           *bg,
		StudentLoadService: sls,
		LessonTypeBinder:   ltb,
	}
}

// NewDefaultStudentGroup creates a new StudentGroup instance with default configuration.
//
// It requires student group id, name, max lessons per day (dl), and busy grid (bg).
func NewDefaultStudentGroup(id uuid.UUID, name string, dl int, bg *BusyGrid) *StudentGroup {
	return NewStudentGroup(id, name, dl, bg, NewStudentLoadService(), NewLessonTypeBinder())
}

// ==========================================================================================================
// ============================================= ConnectedGroups ============================================
// ==========================================================================================================

// AddConnectedGroup creates a connection between student groups by adding each group to the other's special field.
// Does not create a duplicate connection if the groups are already connected.
func (sg *StudentGroup) AddConnectedGroup(other *StudentGroup) {
	if slices.Contains(sg.connectedGroups, other) {
		return
	}

	other.connectedGroups = append(other.connectedGroups, sg)
	sg.connectedGroups = append(sg.connectedGroups, other)
}

func (sg *StudentGroup) CountConnectedGroupsNumber() int {
	return len(sg.connectedGroups)
}

// ==========================================================================================================
// =========================================== BusyGrid OVERRIDES ===========================================
// ==========================================================================================================

// func (sg *StudentGroup) CountSlotsAtDay(day int) (count int) {
// 	if day < 0 || day > 6 {
// 		return
// 	}
//
// 	for week := 0; sg.CheckDay(day+week*7) == nil; week++ {
// 		currentDay := day + week*7
// 		delta := 0
// 		for slot := range sg.Grid[currentDay] {
// 			if !sg.IsBusy(LessonSlot{Day: currentDay, Slot: slot}) {
// 				delta++
// 			}
// 		}
// 		if delta > sg.MaxLessonsPerDay {
// 			delta = sg.MaxLessonsPerDay
// 		}
// 		count += delta
// 	}
// 	return
// }

// GetFreeSlots returns free slots of the selected day (day).
//
// If a day out of the grid returns an empty array.
func (sg *StudentGroup) GetFreeSlots(day int) (slots []float32) {
	if err := sg.CheckDay(day); err != nil {
		return []float32{}
	}

	slots = make([]float32, len(sg.Grid[day]))

	// the group hasn't lesson that day
	if sg.CountLessonsOn(day) == 0 {
		for i := range slots {
			slots[i] = sg.Grid[day][i]
		}
		return
	}

	for i := range sg.Grid[day] {
		// skip first element to perform away algorithm correctly
		if i == 0 {
			continue
		}

		// if there is a lesson at the current slot and the previous slot is free, mark the previous slot as available
		if sg.IsBusy(LessonSlot{Day: day, Slot: i}) {
			if !sg.IsBusy(LessonSlot{Day: day, Slot: i - 1}) {
				slots[i-1] = sg.Grid[day][i-1]
			}
			// if the current slot is busy and the previous slot is free, mark the current slot as available
		} else {
			if sg.IsBusy(LessonSlot{Day: day, Slot: i - 1}) {
				slots[i] = sg.Grid[day][i]
			}
		}
	}
	return
}

// MoveLessonTo uses the MoveLessonTo BusyGrid method to move the lesson. If the lesson can't be moved
// returns the error generated by the LessonCanBeMoved method.
func (sg *StudentGroup) MoveLessonTo(lesson *Lesson, to LessonSlot) error {
	if err := sg.LessonCanBeMoved(lesson, to); err != nil {
		return err
	}

	return sg.BusyGrid.MoveLessonTo(lesson.LessonSlot, to)
}

// LessonCanBeMoved uses the LessonCanBeMoved BusyGrid check on the first order, then additionally
// checks the type of the day.
func (sg *StudentGroup) LessonCanBeMoved(lesson *Lesson, to LessonSlot) error {
	if err := sg.BusyGrid.LessonCanBeMoved(lesson.LessonSlot, to); err != nil {
		return err
	}

	if !sg.IsDayOfType(lesson.Type, to.Day) {
		return fmt.Errorf("%d is not day of the type %s", to.Day, lesson.Type.Name)
	}

	return nil
}

// ==========================================================================================================
// ======================================= LessonTypeBinder OVERRIDES =======================================
// ==========================================================================================================

// GetNextDayOfType finds the next free day of the selected lesson type. Starts with the start day position.
// The method does NOT return days where the student group is already fully loaded.
//
// Returns -1 if the student group doesn't have a free day.
func (sg *StudentGroup) GetNextDayOfType(lType *LessonType, startDay int) int {
	// if len(sg.LessonTypeBinding[lType].Days) == 0 {
	// 	return -1
	// }

	for i := startDay; sg.CheckDay(i) == nil; i++ {
		if sg.IsDayOfType(lType, i) {
			if !sg.CheckDayOverload(i) {
				return i
			}
		}
	}

	return -1
}

// HasLessonsOfType Returns true if the student group has lessons of type (lType).
func (sg *StudentGroup) HasLessonsOfType(lType *LessonType) bool {
	return slices.Contains(sg.GetOwnLessonTypes(), lType)
}

// BindWeek uses the BindWeek method on the first order.
// Then it binds to connected groups, ignoring their errors.
func (sg *StudentGroup) BindWeek(lType *LessonType, week int) error {
	if err := sg.LessonTypeBinder.BindWeek(lType, week); err != nil {
		return err
	}

	for _, group := range sg.connectedGroups {
		group.LessonTypeBinder.BindWeek(lType, week)
	}

	return nil
}

// BindWeekday uses the BindWeekday method on the first order.
// Then it binds to connected groups, ignoring their errors.
func (sg *StudentGroup) BindWeekday(lType *LessonType, day int) error {
	if err := sg.LessonTypeBinder.BindWeekday(lType, day); err != nil {
		return err
	}

	for _, group := range sg.connectedGroups {
		group.LessonTypeBinder.BindWeekday(lType, day)
	}

	return nil
}

// ==========================================================================================================
// ================================================= OTHERS =================================================
// ==========================================================================================================

// CheckDayOverload returns false if the student group has fewer lessons than the limit, set as MaxLessonsPerDay.
// It uses the CountLessonsOn method to get the number of lessons.
func (sg *StudentGroup) CheckDayOverload(day int) bool {
	if err := sg.CheckDay(day); err != nil {
		return true
	}

	return sg.CountLessonsOn(day) >= sg.MaxLessonsPerDay
}

// AddLesson registers the lesson at all dependent services.
//
// Returns an error if CheckLesson fails.
func (sg *StudentGroup) AddLesson(lesson *Lesson) error {
	err := sg.CheckLesson(lesson)
	if err != nil {
		return err
	}

	sg.SetSlotBusyState(lesson.LessonSlot, true)
	// TODO: Sharing busy state between groups causes bug: student group has a window, but between lessons of connected groups
	// for _, g := range sg.connectedGroups {
	// 	g.SetSlotBusyState(lesson.LessonSlot, true)
	// }
	sg.StudentLoadService.AddLesson(lesson)

	return err
}

// CheckLesson checks if the lesson can be added. It checks slot validation, availability,
// day load, curriculum limits and possible formation of the gap.
//
// Return an error if validation fails.
func (sg *StudentGroup) CheckLesson(lesson *Lesson) error {
	if err := sg.CheckSlot(lesson.LessonSlot); err != nil {
		return err
	}
	if !sg.IsFree(lesson.LessonSlot) {
		return fmt.Errorf("student group is busy")
	}
	if sg.CheckDayOverload(lesson.Day) {
		return fmt.Errorf("student group is fully loaded for this day")
	}
	if err := sg.CheckGapOnAdd(lesson.LessonSlot); err != nil {
		return err
	}

	if sg.IsEnoughLessons() {
		return fmt.Errorf("student group is fully loaded")
	}

	if !sg.IsDayOfType(lesson.Type, lesson.Day) {
		return fmt.Errorf("type %s not in the correct day", lesson.Type.Name)
	}

	return nil
}

// CountOvertimeLessons returns the total number of overtime lessons (above the daily limit) for the student group.
func (sg *StudentGroup) CountOvertimeLessons() (result int) {
	for day := 0; true; day++ {
		count := sg.CountLessonsOn(day)
		if count == -1 {
			break
		}
		result += max(0, count-sg.MaxLessonsPerDay)
	}
	return
}

// CountInvalidLessonsType returns the total number of lesson scheduled on days that are not allowed for their type.
func (sg *StudentGroup) CountInvalidLessonsByType() (result int) {
	lessons := sg.GetAssignedLessons()
	for _, lesson := range lessons {
		if !sg.IsDayOfType(lesson.Type, lesson.Day) {
			result += 1
		}
	}

	return
}

// ==========================================================================================================
// =========================================== StudentLoadService ===========================================
// ==========================================================================================================

// StudentLoadService tracks and evaluates the study workload for a StudentGroup.
type StudentLoadService interface {
	LoadService                            // Base interface for load validation logic.
	AddLoad(key StudentLoadKey, hours int) // Registers a new required load entry.
	GetOwnLessonTypes() []*LessonType
}

// NewStudentLoadService creates a new basic StudentLoadService instance.
func NewStudentLoadService() StudentLoadService {
	return &studentLoadService{
		loads: make(map[StudentLoadKey]studentLoad),
	}
}

// studentLoadService is the basic implementation of the StudentLoadService interface.
type studentLoadService struct {
	loads map[StudentLoadKey]studentLoad
}

func (s *studentLoadService) AddLesson(lesson *Lesson) {
	key := StudentLoadKey{
		discipline: lesson.Discipline,
		lessonType: lesson.Type,
		teacher:    lesson.Teacher,
	}

	load, ok := s.loads[key]
	if ok {
		load.checker.AddLesson(lesson)
		return
	}

	panic("student load not found")
}
func (s *studentLoadService) CountHourDeficit() (count int) {
	for _, load := range s.loads {
		count += load.checker.CountHourDeficit()
	}
	return
}
func (s *studentLoadService) IsEnoughLessons() bool {
	for _, load := range s.loads {
		if !load.checker.IsEnoughLessons() {
			return false
		}
	}
	return true
}
func (s *studentLoadService) GetAssignedLessons() (result []*Lesson) {
	for _, load := range s.loads {
		result = append(result, load.checker.GetAssignedLessons()...)
	}
	return
}
func (s *studentLoadService) AddLoad(key StudentLoadKey, hours int) {
	if _, ok := s.loads[key]; !ok {
		s.loads[key] = studentLoad{
			checker: NewLoadService(hours),
		}
	}
}
func (s *studentLoadService) GetOwnLessonTypes() (result []*LessonType) {
	for key := range s.loads {
		if !slices.Contains(result, key.lessonType) {
			result = append(result, key.lessonType)
		}
	}

	return
}

// NewStudentLoadKey creates a new StudentLoadKey instance.
//
// It requires pointers to discipline, lesson type and teacher.
func NewStudentLoadKey(d *Discipline, lt *LessonType, t *Teacher) StudentLoadKey {
	return StudentLoadKey{
		discipline: d,
		lessonType: lt,
		teacher:    t,
	}
}

// StudentLoadKey is a composite key used to identify a student load entry.
type StudentLoadKey struct {
	discipline *Discipline
	lessonType *LessonType
	teacher    *Teacher
}

type studentLoad struct {
	checker LoadService
}
